# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

"""
This module gives access to some functions of the spams C++ library.
The functions defined here should not be called directly.
Use of spams functions should only be done through module spams.
"""

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_spams_wrap', [dirname(__file__)])
        except ImportError:
            import _spams_wrap
            return _spams_wrap
        if fp is not None:
            try:
                _mod = imp.load_module('_spams_wrap', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _spams_wrap = swig_import_helper()
    del swig_import_helper
else:
    import _spams_wrap
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def im2col_sliding(*args):
  return _spams_wrap.im2col_sliding(*args)
im2col_sliding = _spams_wrap.im2col_sliding

def sort(*args):
  """sort(Vector<(double)> v, bool mode)"""
  return _spams_wrap.sort(*args)

def mult(*args):
  """
    mult(Matrix<(double)> X, Matrix<(double)> Y, Matrix<(double)> XY, 
        bool transX, bool transY, double a, 
        double b)
    """
  return _spams_wrap.mult(*args)

def AAt(*args):
  """AAt(SpMatrix<(double)> A, Matrix<(double)> B)"""
  return _spams_wrap.AAt(*args)

def XAt(*args):
  """XAt(SpMatrix<(double)> A, Matrix<(double)> X, Matrix<(double)> XAt)"""
  return _spams_wrap.XAt(*args)

def applyBayerPattern(*args):
  """applyBayerPattern(Vector<(double)> v, int offset)"""
  return _spams_wrap.applyBayerPattern(*args)

def conjugateGradient(*args):
  """
    conjugateGradient(Matrix<(double)> A, Vector<(double)> b, Vector<(double)> x, 
        double tol, int itermax)
    """
  return _spams_wrap.conjugateGradient(*args)

def invSym(*args):
  """invSym(Matrix<(double)> A)"""
  return _spams_wrap.invSym(*args)

def normalize(*args):
  """normalize(Matrix<(double)> A)"""
  return _spams_wrap.normalize(*args)
L1COEFFS = _spams_wrap.L1COEFFS
L2ERROR = _spams_wrap.L2ERROR
PENALTY = _spams_wrap.PENALTY
SPARSITY = _spams_wrap.SPARSITY
L2ERROR2 = _spams_wrap.L2ERROR2
PENALTY2 = _spams_wrap.PENALTY2

def sparseProject(*args):
  """
    sparseProject(Matrix<(double)> U, Matrix<(double)> V, double thrs, 
        int mode, double lambda1, double lambda2, double lambda3, 
        bool pos, int numThreads)
    """
  return _spams_wrap.sparseProject(*args)

def lassoD(*args):
  """
    lassoD(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> path, 
        bool return_reg_path, int L, double constraint, 
        double lambda2, constraint_type mode, 
        bool pos, bool ols, int numThreads, int max_length_path, 
        bool verbose, bool cholevsky) -> SpMatrix<(double)>
    """
  return _spams_wrap.lassoD(*args)

def lassoQq(*args):
  """
    lassoQq(Matrix<(double)> X, Matrix<(double)> Q, Matrix<(double)> q, 
        Matrix<(double)> path, bool return_reg_path, 
        int L, double constraint, double lambda2, 
        constraint_type mode, bool pos, bool ols, 
        int numThreads, int max_length_path, bool verbose, 
        bool cholevsky) -> SpMatrix<(double)>
    """
  return _spams_wrap.lassoQq(*args)

def lassoMask(*args):
  """
    lassoMask(Matrix<(double)> X, Matrix<(double)> D, Matrix<(bool)> B, 
        int L, double constraint, double lambda2, 
        constraint_type mode, bool pos, int numThreads, 
        bool verbose) -> SpMatrix<(double)>
    """
  return _spams_wrap.lassoMask(*args)

def lassoWeighted(*args):
  """
    lassoWeighted(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> W, 
        int L, double constraint, constraint_type mode, 
        bool pos, int numThreads, bool verbose) -> SpMatrix<(double)>
    """
  return _spams_wrap.lassoWeighted(*args)

def omp(*args):
  """
    omp(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> path, 
        bool return_reg_path, bool given_L, 
        Vector<(int)> L, bool given_eps, Vector<(double)> eps, 
        bool given_Lambda, Vector<(double)> Lambda, 
        int numThreads) -> SpMatrix<(double)>
    """
  return _spams_wrap.omp(*args)

def ompMask(*args):
  """
    ompMask(Matrix<(double)> X, Matrix<(double)> D, Matrix<(bool)> B, 
        Matrix<(double)> path, bool return_reg_path, 
        bool given_L, Vector<(int)> L, bool given_eps, 
        Vector<(double)> eps, bool given_Lambda, 
        Vector<(double)> Lambda, int numThreads) -> SpMatrix<(double)>
    """
  return _spams_wrap.ompMask(*args)

def somp(*args):
  """
    somp(Matrix<(double)> X, Matrix<(double)> D, Vector<(int)> groups, 
        int LL, double eps, int numThreads) -> SpMatrix<(double)>
    """
  return _spams_wrap.somp(*args)

def cd(*args):
  """
    cd(Matrix<(double)> X, Matrix<(double)> D, SpMatrix<(double)> alpha, 
        double lambda1, constraint_type mode, 
        int itermax, double tol, int numThreads) -> SpMatrix<(double)>
    """
  return _spams_wrap.cd(*args)

def l1L2BCD(*args):
  """
    l1L2BCD(Matrix<(double)> X, Matrix<(double)> D, Matrix<(double)> alpha0, 
        Vector<(int)> groups, double lambda1, 
        constraint_type mode, int itermax, double tol, 
        int numThreads)
    """
  return _spams_wrap.l1L2BCD(*args)
L2 = _spams_wrap.L2
L1L2 = _spams_wrap.L1L2
L1L2FL = _spams_wrap.L1L2FL
L1L2MU = _spams_wrap.L1L2MU

def alltrainDL(*args):
  """
    alltrainDL(Data<(double)> X, bool in_memory, Matrix<(double)> omA, 
        Matrix<(double)> omB, Vector<(int)> omiter, 
        bool return_model, Matrix<(double)> m_A, 
        Matrix<(double)> m_B, int m_iter, Matrix<(double)> D1, 
        int num_threads, int batch_size, int K, 
        double lambda1, double lambda2, int iter, 
        double t0, constraint_type mode, bool posAlpha, 
        bool posD, bool expand, constraint_type_D modeD, 
        bool whiten, bool clean, bool verbose, 
        double gamma1, double gamma2, double rho, 
        int iter_updateD, bool stochastic, int modeParam, 
        bool batch, bool log, char logName) -> Matrix<(double)>
    """
  return _spams_wrap.alltrainDL(*args)

def fistaFlat(*args):
  """
    fistaFlat(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(int)> groups, int num_threads, int max_it, 
        double L0, bool fixed_step, double gamma, 
        double _lambda, double delta, double lambda2, 
        double lambda3, double a, double b, double c, 
        double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, bool admm, 
        bool intercept, bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, 
        bool clever, bool log, bool ista, bool subgrad, 
        char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, int size_group, 
        bool sqrt_step, bool transpose) -> Matrix<(double)>
    """
  return _spams_wrap.fistaFlat(*args)

def fistaTree(*args):
  """
    fistaTree(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(double)> eta_g, SpMatrix<(bool)> groups, 
        Vector<(int)> own_variables, Vector<(int)> N_own_variables, 
        int num_threads, int max_it, 
        double L0, bool fixed_step, double gamma, 
        double _lambda, double delta, double lambda2, 
        double lambda3, double a, double b, double c, 
        double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, bool admm, 
        bool intercept, bool resetflow, char name_regul, 
        char name_loss, bool verbose, bool pos, 
        bool clever, bool log, bool ista, bool subgrad, 
        char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, int size_group, 
        bool sqrt_step, bool transpose) -> Matrix<(double)>
    """
  return _spams_wrap.fistaTree(*args)

def fistaGraph(*args):
  """
    fistaGraph(Matrix<(double)> X, AbstractMatrixB<(double)> D, Matrix<(double)> alpha0, 
        Matrix<(double)> alpha, 
        Vector<(double)> eta_g, SpMatrix<(bool)> groups, 
        SpMatrix<(bool)> groups_var, int num_threads, 
        int max_it, double L0, bool fixed_step, 
        double gamma, double _lambda, double delta, 
        double lambda2, double lambda3, double a, double b, 
        double c, double tol, int it0, int max_iter_backtracking, 
        bool compute_gram, bool lin_admm, 
        bool admm, bool intercept, bool resetflow, 
        char name_regul, char name_loss, bool verbose, 
        bool pos, bool clever, bool log, bool ista, 
        bool subgrad, char logName, bool is_inner_weights, 
        Vector<(double)> inner_weights, 
        int size_group, bool sqrt_step, bool transpose) -> Matrix<(double)>
    """
  return _spams_wrap.fistaGraph(*args)

def proximalFlat(*args):
  """
    proximalFlat(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(int)> groups, 
        int num_threads, double lambda1, 
        double lambda2, double lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, 
        int size_group, bool transpose) -> Vector<(double)>
    """
  return _spams_wrap.proximalFlat(*args)

def proximalTree(*args):
  """
    proximalTree(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(double)> eta_g, 
        SpMatrix<(bool)> groups, 
        Vector<(int)> own_variables, Vector<(int)> N_own_variables, 
        int num_threads, double lambda1, 
        double lambda2, double lambda3, bool intercept, 
        bool resetflow, char name_regul, bool verbose, 
        bool pos, bool clever, bool eval, int size_group, 
        bool transpose) -> Vector<(double)>
    """
  return _spams_wrap.proximalTree(*args)

def proximalGraph(*args):
  """
    proximalGraph(Matrix<(double)> alpha0, Matrix<(double)> alpha, Vector<(double)> eta_g, 
        SpMatrix<(bool)> groups, 
        SpMatrix<(bool)> groups_var, int num_threads, 
        double lambda1, double lambda2, double lambda3, 
        bool intercept, bool resetflow, char name_regul, 
        bool verbose, bool pos, bool clever, 
        bool eval, int size_group, bool transpose) -> Vector<(double)>
    """
  return _spams_wrap.proximalGraph(*args)


